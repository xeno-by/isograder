#!/usr/bin/env python
# coding=utf-8
import os, sys, logging, inspect, traceback

def message_unexpected_failure(explanation):
  return "unexpected failure in isograder:" + "\n" + str(explanation)
def message_bad_python_version(actual):
  return "need python 2.7, you have " + str(actual)
def message_bad_command_line(explanation):
  return str(explanation) + "\n" + "usage: " + sys.argv[0] + " [-v]"
def message_bad_parse(explanation, line_number, line):
  return "error parsing the correction sheet:" + "\n" + "line " + str(line_number) + ": " + explanation + "\n" + line + "\n" + "^"
def message_only_blanks_and_sections_at_top_level():
  return "at the top-level of a correction sheet, only blank lines and section lines are allowed"
def message_no_sections_at_top_level():
  return "at the top-level of a correction sheet, exactly one section is require"
def message_multiple_sections_at_top_level():
  return "at the top-level of a correction sheet, exactly one section is require"

logFormatter = logging.Formatter("%(asctime)-15s [%(levelname)s] %(message)s")
rootLogger = logging.getLogger()
rootLogger.setLevel(logging.CRITICAL)
logRoot = os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe())))
fileHandler = logging.FileHandler("{0}/isograder.log".format(logRoot))
fileHandler.setFormatter(logFormatter)
rootLogger.addHandler(fileHandler)
consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logFormatter)
rootLogger.addHandler(consoleHandler)
logger = logging.getLogger("isocollect")

def fail_bad_python_version(): logger.critical(message_bad_python_version(sys.version_info)); exit(1)
if sys.version_info < (2, 7) or (2, 8) <= sys.version_info: fail_bad_python_version()

def custom_except_hook(exctype, value, tb):
  logger.critical(message_unexpected_failure("\n".join(traceback.format_exception(exctype, value, tb))))
  logger.info("Isograder shutting down...")
  exit(1)
sys.excepthook = custom_except_hook

def fail_bad_command_line(explanation): logger.critical(message_bad_command_line(explanation)); exit(1)
flags = filter(lambda arg: arg.startswith("-"), sys.argv[1:])
other = filter(lambda arg: not arg.startswith("-"), sys.argv[1:])
for flag in filter(lambda flag: flag != "-v", flags): fail_bad_command_line("unrecognized flag: " + flag)
for other in other: fail_bad_command_line("unrecognized argument: " + other)
verbose = "-v" in flags
if verbose: rootLogger.setLevel(logging.INFO)
logger.info("Isograder starting up...")

# this is an amazing level of verbosity in comparison with Scala
class Error(object):
  def __init__(self, message):
    self.message = message
class Sheet(object):
  def __init__(self, parts):
    self.parts = parts
  @staticmethod
  def parse(lines):
    parts = []
    while True:
      if lines:
        result, remaining_lines = Part.parse(lines)
        def move_on():
          parts.append(result)
          lines = remaining_lines
        if isinstance(result, Error):
          return (result, remaining_lines)
        elif isinstance(result, Blank):
          move_on()
        elif isinstance(result, Section):
          if len(filter(lambda part: isinstance(part, Section), parts)) != 0:
            return (Error(message_only_one_section_at_top_level()), lines)
          else:
            move_on()
        else:
          return (Error(message_only_blanks_and_sections_at_top_level()), lines)
      else:
        break
    if len(filter(lambda part: isinstance(part, Section), parts)) != 0: return (Sheet(parts), lines)
    else: return (Error(message_no_sections_at_top_level()), lines)
class Part(object):
  @staticmethod
  def parse(lines):
    return (Error("Part.parse is not implemented yet"), lines)
class Section(Part):
  def __init__(self, parts):
    self.parts = parts
  @staticmethod
  def parse(lines):
    return (Error("Section.parse is not implemented yet"), lines)
class Blank(Part):
  def __init__(self, str):
    self.str = str
  @staticmethod
  def parse(lines):
    return (Error("Blank.parse is not implemented yet"), lines)
class Header(Part):
  def __init__(self, str):
    self.str = str
  @staticmethod
  def parse(lines):
    return (Error("Header.parse is not implemented yet"), lines)
class Grade(Part):
  def __init__(self, grade, explanation):
    self.grade = grade
    self.explanation = explanation
  @staticmethod
  def parse(lines):
    return (Error("Grade.parse is not implemented yet"), lines)

input_string = sys.stdin.read()
input_lines = input_string.strip().split("\n")
result, remaining_lines = Sheet.parse(input_lines)
if type(result) == Sheet:
  input_sheet = result
  assert len(remaining_lines) == 0
elif type(result) == Error:
  line_number = len(input_lines) - len(remaining_lines) + 1
  line = remaining_lines[0] if remaining_lines else ""
  logger.critical(message_bad_parse(result.message, line_number, line))
  exit(1)

logger.info("Isograder shutting down...")