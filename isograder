#!/usr/bin/env python
# coding=utf-8
import os, sys, logging, inspect, traceback, re

def message_unexpected_failure(explanation):
  return "unexpected failure in isograder:" + "\n" + str(explanation)
def message_bad_python_version(actual):
  return "need python 2.7, you have " + str(actual)
def message_bad_command_line(explanation):
  return str(explanation) + "\n" + "usage: " + sys.argv[0] + " [-v]"
def message_bad_parse(explanation, line_number, line):
  return "error parsing the correction sheet:" + "\n" + "line " + str(line_number) + ": " + explanation + "\n" + line + "\n" + "^"
def message_unexpected_eof(what):
  return "unexpected end of file when parsing " + what
def message_only_blanks_and_sections_at_top_level():
  return "at the top-level of a correction sheet, only blank lines and section lines are allowed"
def message_no_sections_at_top_level():
  return "exactly one section is allowed at the top level of a correction sheet"
def message_multiple_sections_at_top_level():
  return "exactly one section is allowed at the top level of a correction sheet"
def message_invalid_section_level(level, actual):
  return "invalid section level: expected " + level + ", actual " + ("*" * actual)
def message_invalid_section_header(level, actual):
  return "invalid section header: expected " + ("*" * level) + " <name> [/<max_grade>], actual " + actual
def message_invalid_line():
  return "invalid line: should either start with */-/+ or end with -"
def message_invalid_grade_header(actual):
  return "invalid grade header: expected [-|+]<number>: <explanation>, actual " + actual

logFormatter = logging.Formatter("%(asctime)-15s [%(levelname)s] %(message)s")
rootLogger = logging.getLogger()
rootLogger.setLevel(logging.CRITICAL)
logRoot = os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe())))
fileHandler = logging.FileHandler("{0}/isograder.log".format(logRoot))
fileHandler.setFormatter(logFormatter)
rootLogger.addHandler(fileHandler)
consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logFormatter)
rootLogger.addHandler(consoleHandler)
logger = logging.getLogger("isocollect")

def fail_bad_python_version(): logger.critical(message_bad_python_version(sys.version_info)); exit(1)
if sys.version_info < (2, 7) or (2, 8) <= sys.version_info: fail_bad_python_version()

def custom_except_hook(exctype, value, tb):
  logger.critical(message_unexpected_failure("\n".join(traceback.format_exception(exctype, value, tb))))
  logger.info("Isograder terminating with an unexpected error...")
  exit(1)
sys.excepthook = custom_except_hook

def fail_bad_command_line(explanation): logger.critical(message_bad_command_line(explanation)); exit(1)
flags = filter(lambda arg: arg.startswith("-"), sys.argv[1:])
other = filter(lambda arg: not arg.startswith("-"), sys.argv[1:])
for flag in filter(lambda flag: flag != "-v", flags): fail_bad_command_line("unrecognized flag: " + flag)
for other in other: fail_bad_command_line("unrecognized argument: " + other)
verbose = "-v" in flags
if verbose: rootLogger.setLevel(logging.INFO)
logger.info("Isograder starting up...")

# this is an amazing level of verbosity in comparison with Scala
class Context(object):
  def __init__(self, level):
    self.level = level
  def __str__(self):
    return "{ level = " + str(self.level) + " }"
class Error(object):
  def __init__(self, message):
    self.message = message
  def __str__(self):
    return "Error(" + str(self.message) + ")"
def parser(target):
  def decorator(meth):
    def wrapped(ctx, lines):
      details = "with " + str(ctx) + " at " + (lines[0] if lines else "[]")
      logger.info("started parsing " + target + " " + details)
      try: return meth(ctx, lines)
      finally: logger.info("finished parsing " + target + " " + details)
    return staticmethod(wrapped)
  return decorator
class Sheet(object):
  def __init__(self, parts):
    self.parts = parts
  def __str__(self):
    return "\n".join(map(lambda part: str(part), self.parts))
  @parser("Sheet")
  def parse(ctx, lines):
    assert ctx.level == 0
    parts = []
    while True:
      if lines:
        result, remaining_lines = Part.parse(ctx, lines)
        if isinstance(result, Error):
          return (result, remaining_lines)
        elif isinstance(result, Blank):
          parts.append(result)
          lines = remaining_lines
          continue
        elif isinstance(result, Section):
          if len(filter(lambda part: isinstance(part, Section), parts)) != 0:
            return (Error(message_multiple_sections_at_top_level()), lines)
          else:
            parts.append(result)
            lines = remaining_lines
            continue
        else:
          return (Error(message_only_blanks_and_sections_at_top_level()), lines)
      else:
        break
    if len(filter(lambda part: isinstance(part, Section), parts)) != 0: return (Sheet(parts), lines)
    else: return (Error(message_no_sections_at_top_level()), lines)
class Part(object):
  @parser("Part")
  def parse(ctx, lines):
    if lines:
      line = lines[0].strip()
      if line == "": return Blank.parse(ctx, lines)
      elif line.startswith("*"): return Section.parse(ctx, lines)
      elif line.startswith("-") or line.startswith("+"): return Grade.parse(ctx, lines)
      else: return Header.parse(ctx, lines)
    else:
      return (Error(message_unexpected_eof("Part")), lines)
class Blank(Part):
  def __init__(self, str):
    self.str = str
  def __str__(self):
    return str(self.str)
  @parser("Blank")
  def parse(ctx, lines):
    if lines:
      line = lines[0].strip()
      assert line == ""
      return (Blank(line), lines[1:])
    else:
      return (Error(message_unexpected_eof("Blank")), lines)
class Section(Part):
  def __init__(self, level, name, max_grade, parts):
    self.level = level
    self.name = name
    self.grade = None
    self.max_grade = max_grade
    self.parts = parts
  def __str__(self):
    header = "*" * self.level +  " " + str(self.name) + " [/" + str(self.max_grade) + "]"
    body = "\n" + "\n".join(map(lambda part: str(part), self.parts)) if self.parts else ""
    return header + body
  @parser("Section")
  def parse(ctx, lines):
    if lines:
      line = lines[0].strip()
      assert line.startswith("*")
      expected_level = ctx.level + 1
      actual_level = len(re.match("^(\*+).*$", line).groups()[0])
      if expected_level == actual_level:
        level = actual_level
        rest = line[level:]
        m = re.match("^\w*(.*?)\w*\[/(\d+)\]$", rest)
        if m:
          name = m.groups()[0].strip()
          max_grade = int(m.groups()[1])
          lines = lines[1:]
          parts = []
          while True:
            if lines:
              line = lines[0]
              # need to allow `* Section\n** Subsection`, but stop at `* Section 1\n* Section 2`
              if line.startswith("*") and not line.startswith("*" * (ctx.level + 2)):
                break
              else:
                result, remaining_lines = Part.parse(Context(ctx.level + 1), lines)
                if isinstance(result, Error):
                  return (result, remaining_lines)
                else:
                  parts.append(result)
                  lines = remaining_lines
                  continue
            else:
              break
          return (Section(level, name, max_grade, parts), lines)
        else:
          return (Error(message_invalid_section_header(level, line)), lines)
      else:
        return (Error(message_invalid_section_level("*" * expected_level, actual_level)), lines)
    else:
      return (Error(message_unexpected_eof("Section")), lines)
class Header(Part):
  def __init__(self, str):
    self.str = str
  def __str__(self):
    return str(self.str)
  @parser("Header")
  def parse(ctx, lines):
    if lines:
      line = lines[0].strip()
      if line.endswith(":"):
        return (Header(line[:-1]), lines[1:])
      else:
        return (Error(message_invalid_line()), lines)
    else:
      return (Error(message_unexpected_eof("Header")), lines)
class Grade(Part):
  def __init__(self, grade, explanation):
    self.grade = grade
    self.explanation = explanation
  def __str__(self):
    return str(self.grade) + ": " + str(self.explanation)
  @parser("Grade")
  def parse(ctx, lines):
    if lines:
      line = lines[0].strip()
      assert line.startswith("-") or line.startswith("+")
      m = re.match("^([-|+]\d+)\w*:\w*(.*?)$", line)
      if m:
        grade = int(m.groups()[0])
        explanation = m.groups()[1]
        return (Grade(grade, explanation), lines[1:])
      else:
        return (Error(message_invalid_grade_header()), lines)
    else:
      return (Error(message_unexpected_eof("Grade")), lines)

input_string = sys.stdin.read()
input_lines = input_string.strip().split("\n")
result, remaining_lines = Sheet.parse(Context(0), input_lines)
if type(result) == Sheet:
  input_sheet = result
  assert len(remaining_lines) == 0
elif type(result) == Error:
  line_number = len(input_lines) - len(remaining_lines) + 1
  line = remaining_lines[0] if remaining_lines else ""
  logger.critical(message_bad_parse(result.message, line_number, line))
  logger.info("Isograder terminating with a parse error...")
  exit(1)

logger.info("Isograder terminating with a success...")